<?php
/*******************************************************************************
 *
 *   CrystalPHP Framework by Crystal Collective
 *   An open source application development framework for PHP
 *
 *   This file is part of CrystalPHP which is released under the MIT License (MIT)
 *
 *   Copyright (c) 2019 - 2019, Crystal Collective
 *
 *   For the full copyright and license information,
 *   please view the LICENSE file that was distributed with this source code.
 *
 ******************************************************************************/

/**
 * User: Pankaj Vaghela
 * Date: 27-05-2019
 * Time: 16:02
 */

namespace CrystalPHP;

class Response{
	public const DEFAULT_RESPONSE_FORMAT = 'html';
	/**
	 * @var Response
	 */
	public static $instance = false;
	/**
	 * Supported data types and static data
	 *
	 */
	public static $formats = ['html', 'xml', 'json', 'qs'];
	public static $contentTypes = [
		'html' => 'text/html',
		'xml' => 'application/xml',
		'json' => 'application/json',
		'qs' => 'text/plain',
	];
	public static $status_codes = array(
		100 => 'Continue',
		101 => 'Switching Protocols',
		200 => 'OK',
		201 => 'Created',
		202 => 'Accepted',
		203 => 'Non-Authoritative Information',
		204 => 'No Content',
		205 => 'Reset Content',
		206 => 'Partial Content',
		300 => 'Multiple Choices',
		301 => 'Moved Permanently',
		302 => 'Found',
		303 => 'See Other',
		304 => 'Not Modified',
		305 => 'Use Proxy',
		306 => '(Unused)',
		307 => 'Temporary Redirect',
		400 => 'Bad Request',
		401 => 'Unauthorized',
		402 => 'Payment Required',
		403 => 'Forbidden',
		404 => 'Not Found',
		405 => 'Method Not Allowed',
		406 => 'Not Acceptable',
		407 => 'Proxy Authentication Required',
		408 => 'Request Timeout',
		409 => 'Conflict',
		410 => 'Gone',
		411 => 'Length Required',
		412 => 'Precondition Failed',
		413 => 'Request Entity Too Large',
		414 => 'Request-URI Too Long',
		415 => 'Unsupported Media Type',
		416 => 'Requested Range Not Satisfiable',
		417 => 'Expectation Failed',
		500 => 'Internal Server Error',
		501 => 'Not Implemented',
		502 => 'Bad Gateway',
		503 => 'Service Unavailable',
		504 => 'Gateway Timeout',
		505 => 'HTTP Version Not Supported',
	);
	/**
	 * @var array http-headers
	 */
	private $headers = array();
	/**
	 * @var string
	 */
	private $output; // Default response format
	/**
	 * @var int level of zip compression
	 */
	private $level = 0;
	/**
	 * @var Registry
	 */
	private $registry;
	private $response = [];
	
	public function __construct(){
		$this->registry = Registry::getInstance();
		$this->output = '';
	}
	
	public static function getInstance(){
		if(static::$instance === false){
			static::$instance = new Response();
		}
		return static::$instance;
	}
	
	public static function sendNotFoundResponse(){
		$body = "<html><head><title>404 Not Found</title></head><body bgcolor='white'><div style='text-align:center'><h1>404 Not Found</h1></div></body></html>";
		Registry::getInstance()->response->sendResponse(404, $body);
	}
	
	public function sendResponse($status, $body){
		
		$this->response = ['status' => $status, 'body' => $body];
		
		$status = (isset($this->response['status'])) ? $this->response['status'] : 200;
		$contentType = $this->_getResponseContentType($this->registry->request->request['content-type']);
		$body = (empty($this->response['body'])) ? '' : $this->response['body'];
		
		$headers = 'HTTP/1.1 ' . $status . ' ' . $this->_getStatusMessage($status);
		
		//Prepare output
		$this->addHeader($headers);
		$this->addHeader('Content-Type: ' . $contentType);
//		$this->addHeader("Access-Control-Allow-Origin:  " . $_SERVER['HTTP_ORIGIN']);
		$this->addHeader("Access-Control-Allow-Credentials: true");
		$this->setOutput($body);
		
		$this->output();
		exit(0);
	}
	
	private function _getResponseContentType($type = null){
		return self::$contentTypes[$type];
	}
	
	private function _getStatusMessage($status){
		return (isset(self::$status_codes[$status])) ? self::$status_codes[$status] : self::$status_codes[500];
	}
	
	/**
	 * @return string
	 */
	public function getOutput(){
		return $this->output;
	}
	
	/**
	 * @param string $stdout
	 * @param null|int $level
	 */
	public function setOutput($stdout, $level = null){
		$this->output = $stdout;
		//Do not compress js-output generated by php! It can be compressed by apache mod_deflate (see your .htaccess file)
		if(in_array($this->headers['content-type'], array(
			'Content-Type: text/javascript; charset=UTF-8',
			'Content-Type: application/javascript; charset=UTF-8'))
		){
			$this->level = 0;
		} else{
			if(is_null($level)){
				$level = $this->registry->get('config') ? (int)$this->registry->get('config')->get('config_compression') : 0;
			}
			$this->level = $level;
		}
	}
	
	public function cleanOutput(){
		unset($this->output);
	}
	
	public function sendJsonResponse(){
		$this->addJSONHeader();
		$this->output();
		exit(0);
	}
	
	public function addJSONHeader(){
		$this->headers['content-type'] = 'Content-Type: application/json';
	}
	
	public function output(){
		if($this->level && $this->registry->get('config')){
			$output = $this->compress($this->output, $this->level);
		} else{
			$output = $this->output;
		}
		if(!headers_sent()){
			foreach($this->headers as $header){
				header($header, true);
			}
		}
		echo $output;
	}
	
	/**
	 * @param string $data
	 * @param int $level
	 * @return string
	 */
	private function compress($data, $level = 0){
		if(isset($_SERVER['HTTP_ACCEPT_ENCODING']) && (strpos($_SERVER['HTTP_ACCEPT_ENCODING'], 'gzip') !== false)){
			$encoding = 'gzip';
		}
		
		if(isset($_SERVER['HTTP_ACCEPT_ENCODING']) && (strpos($_SERVER['HTTP_ACCEPT_ENCODING'], 'x-gzip') !== false)){
			$encoding = 'x-gzip';
		}
		
		if(!isset($encoding)){
			return $data;
		}
		
		if(!extension_loaded('zlib') || ini_get('zlib.output_compression')){
			return $data;
		}
		
		if(headers_sent()){
			return $data;
		}
		
		if(connection_status()){
			return $data;
		}
		
		$this->addHeader('Content-Encoding: ' . $encoding);
		
		return gzencode($data, (int)$level);
	}
	
	/**
	 * @param string $header
	 */
	public function addHeader($header){
		$header_name = explode(":", $header);
		$header_name = strtolower(trim($header_name[0]));
		$this->headers[$header_name] = $header;
	}
	
	public function __get($name){
		return $this->registry->get($name);
	}
	
	public function __set($name, $value){
		$this->registry->set($name, $value);
	}
	
}